import java.io.BufferedReader;
import java.io.DataInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.Arrays;
import java.util.Comparator;
import java.util.StringTokenizer;

public class Main {
    public static void main(String[] args) throws IOException {
        PrintWriter out = new PrintWriter(System.out);
        //Scanner sc = new Scanner();
        Reader in = new Reader();
        Main solver = new Main();
        solver.solve(out, in);
        out.flush();
        out.close();

    }
    
    
    void solve(PrintWriter out, Reader in) throws IOException{   
        int n = in.nextInt();
        int q = in.nextInt();
        
        arr = new int[n];
        vers = new Node[n];
        for(int i=0 ;i<n ;i++) arr[i] = in.nextInt();
        Node root = new Node();
        vers[0] = root;
        build(root,0,n-1);
        
        
        vers[1] = new Node();
        update(vers[0],vers[1],0,n-1,2,1);
        
    }
    
    static int[] arr ;
    static Node[] vers;
    
    static void build(Node node, int start, int end){
        
        // Leaf node will have a single element
        if(start == end)   node.c = arr[start];
        else {
            int mid = (start + end) / 2;
            // Recurse on the left child
            Node temp = new Node();
            node.l = temp;
            build(node.l, start, mid);
            // Recurse on the right child
            temp = new Node();
            node.r = temp;
            build(node.r, mid+1, end);
            // Internal node will have the sum of both of its children
            
            node.c = node.l.c + node.r.c;
        }
    }
    
    static void update(Node prev,Node curr, int start, int end, int idx,int val){
        if(start == end){
            // Leaf node
            curr.c = val;
        }
        else{
            int mid = (start + end) / 2;
            if(idx <= mid){
                // If idx is in the left child, recurse on the left child
                Node temp = new Node();
                curr.l = temp;
                update(prev.l,curr.l, start, mid, idx,val);
                curr.r = prev.r;
            }
            else{
                // if idx is in the right child, recurse on the right child
                Node temp = new Node();
                curr.r = temp;
                curr.l = prev.l;
                update(prev.r,curr.r, mid+1, end, idx,val);
            }
            
            curr.c = curr.l.c+curr.r.c;
        }
    }
    
    static int query(Node node, int start, int end, int l, int r){
        if(r < start || end < l){
            // range represented by a node is completely outside the given range
            return 0;
        }
        if(l <= start && end <= r){
            // range represented by a node is completely inside the given range
            return node.c;
        }
        // range represented by a node is partially inside and partially outside the given range
        int mid = (start + end) / 2;
        int p1 = query(node.l, start, mid, l, r);
        int p2 = query(node.r, mid+1, end, l, r);
        
        return p1+p2;
    }
    
    static class Node{
        int c;
        Node l,r;
        
        Node(){
            this.l = null;
            this.r = null;
            this.c = 0;
        }
    }
    
    static class Reader {
        final private int BUFFER_SIZE = 1 << 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;
 
        public Reader()
        {
            din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }
 
        public Reader(String file_name) throws IOException
        {
            din = new DataInputStream(new FileInputStream(file_name));
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }
 
        public String readLine() throws IOException
        {
            byte[] buf = new byte[64]; // line length
            int cnt = 0, c;
            while ((c = read()) != -1)
            {
                if (c == '\n')
                    break;
                buf[cnt++] = (byte) c;
            }
            return new String(buf, 0, cnt);
        }
 
        public int nextInt() throws IOException
        {
            int ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do
            {
                ret = ret * 10 + c - '0';
            }  while ((c = read()) >= '0' && c <= '9');
 
            if (neg)
                return -ret;
            return ret;
        }
 
        public long nextLong() throws IOException
        {
            long ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do {
                ret = ret * 10 + c - '0';
            }
            while ((c = read()) >= '0' && c <= '9');
            if (neg)
                return -ret;
            return ret;
        }
 
        public double nextDouble() throws IOException
        {
            double ret = 0, div = 1;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
 
            do {
                ret = ret * 10 + c - '0';
            }
            while ((c = read()) >= '0' && c <= '9');
 
            if (c == '.')
            {
                while ((c = read()) >= '0' && c <= '9')
                {
                    ret += (c - '0') / (div *= 10);
                }
            }
 
            if (neg)
                return -ret;
            return ret;
        }
 
        private void fillBuffer() throws IOException
        {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1)
                buffer[0] = -1;
        }
 
        private byte read() throws IOException
        {
            if (bufferPointer == bytesRead)
                fillBuffer();
            return buffer[bufferPointer++];
        }
 
        public void close() throws IOException
        {
            if (din == null)
                return;
            din.close();
        }
    }
    
    static class Scanner  {
        BufferedReader br;
        StringTokenizer st;
 
        public Scanner()
        {
            br = new BufferedReader(new
                     InputStreamReader(System.in));
        }
 
        String next()
        {
            while (st == null || !st.hasMoreElements())
            {
                try
                {
                    st = new StringTokenizer(br.readLine());
                }
                catch (IOException  e)
                {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }
 
        int nextInt()
        {
            return Integer.parseInt(next());
        }
 
        long nextLong()
        {
            return Long.parseLong(next());
        }
 
        double nextDouble()
        {
            return Double.parseDouble(next());
        }
 
        String nextLine()
        {
            String str = "";
            try
            {
                str = br.readLine();
            }
            catch (IOException e)
            {
                e.printStackTrace();
            }
            return str;
        }
    }
}
